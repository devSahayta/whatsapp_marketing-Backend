// controllers/chatController.js
import { supabase } from "../config/supabase.js";

/**
 * Ensure a chat exists for (phone_number, event_id).
 * If not exists, insert and return the new chat.
 * NOTE: If your chats.chat_id is auto-generated in Postgres (uuid DEFAULT gen_random_uuid()),
 * we don't set chat_id here — Supabase will return it for us.
 */

export async function ensureChat({ event_id, phone_number, person_name }) {
  // try to find exact chat for event + phone
  let { data: existing, error: findErr } = await supabase
    .from("chats")
    .select("*")
    .eq("event_id", event_id)
    .eq("phone_number", phone_number)
    .maybeSingle();

  if (findErr) {
    console.error(":x: ensureChat find error:", findErr);
    throw findErr;
  }

  if (existing) return existing;

  // Insert new chat row; let DB generate chat_id
  const { data: inserted, error: insertErr } = await supabase
    .from("chats")
    .insert([
      {
        event_id,
        phone_number,
        person_name,
        last_message: "", // set empty string instead of null
        last_message_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
      },
    ])
    .select();

  if (insertErr || !inserted || !inserted[0]) {
    console.error(":x: ensureChat insert error:", insertErr);
    throw insertErr || new Error("Failed to insert chat row");
  }

  return inserted[0];
}

/**
 * Save a message row.
 * If your messages.message_id is auto-generated by DB, omit message_id.
 * Returns inserted message row.
 *
 *
 */

export async function saveMessage({
  chat_id,
  sender_type = "user",
  message,
  message_type = "text",
  media_path = null,
}) {
  if (!message || message.trim() === "") {
    message = `[${(message_type || "TEXT").toUpperCase()}]`;
  }

  const payload = {
    chat_id,
    sender_type,
    message,
    message_type,
    media_path, // :white_check_mark: STORE PATH ONLY
    created_at: new Date().toISOString(),
  };

  const { data: inserted, error } = await supabase
    .from("messages")
    .insert([payload])
    .select();

  if (error) throw error;

  await supabase
    .from("chats")
    .update({
      last_message: message,
      last_message_at: new Date().toISOString(),
    })
    .eq("chat_id", chat_id);

  return inserted[0];
}

/**
 * Fetch chats for an event — useful for left sidebar.
 * Returns chats ordered by last_message_at desc, then created_at.
 */
export async function getChatsForEvent({ event_id, limit = 100, offset = 0 }) {
  const { data, error } = await supabase
    .from("chats")
    .select(
      "chat_id, event_id, phone_number, person_name, last_message, created_at, last_message_at,mode"
    )
    .eq("event_id", event_id)
    .order("last_message_at", { ascending: false, nulls: "last" })
    .order("created_at", { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) {
    console.error(":x: getChatsForEvent error:", error);
    throw error;
  }
  return data || [];
}

/**
 * Fetch messages for a chat with pagination.
 * Returns messages in chronological order (oldest -> newest)
 */
export async function getMessagesForChat({
  chat_id,
  limit = 50,
  before = null,
}) {
  let query = supabase
    .from("messages")
    .select(
      "message_id, chat_id, sender_type, message, message_type, media_path, created_at, buttons"
    )
    .eq("chat_id", chat_id)
    .order("created_at", { ascending: true })
    .limit(limit);

  if (before) {
    query = supabase
      .from("messages")
      .select(
        "message_id, chat_id, sender_type, message, message_type, media_path, created_at"
      )
      .eq("chat_id", chat_id)
      .lt("created_at", before)
      .order("created_at", { ascending: true })
      .limit(limit);
  }

  const { data, error } = await query;
  if (error) {
    console.error(":x: getMessagesForChat error:", error);
    throw error;
  }

  const messages = data || [];

  // :fire: Auto-generate new signed URLs for messages with media_path
  for (let msg of messages) {
    if (!msg.media_path) continue;

    const { data: signed } = await supabase.storage
      .from("participant-docs")
      .createSignedUrl(msg.media_path, 60 * 60 * 24); // 24 hours is ideal

    if (signed?.signedUrl) {
      msg.media_path = signed.signedUrl;
    }
  }

  return messages;
}
